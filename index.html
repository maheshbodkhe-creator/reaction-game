<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>React/or â€” Reaction Timer</title>

  <!-- Favicon from project root -->
  <link rel="icon" type="image/png" href="favicon.png" />

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600;700;800&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet" />

  <!-- Three.js r128 via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    /* ============================================================
       DESIGN TOKENS
       ============================================================ */
    :root {
      --bg:           #0F1117;
      --surface:      #1C1F2E;
      --surface-2:    #252840;
      --accent:       #6EE7B7;
      --accent-dim:   rgba(110,231,183,0.12);
      --accent-glow:  rgba(110,231,183,0.35);
      --danger:       #F87171;
      --danger-dim:   rgba(248,113,113,0.12);
      --warn:         #FBBF24;
      --warn-dim:     rgba(251,191,36,0.12);
      --text:         #F1F5F9;
      --muted:        #64748B;
      --border:       rgba(255,255,255,0.06);
      --font-display: 'Oxanium', monospace;
      --font-ui:      'Inter', sans-serif;
      --radius:       16px;
      --radius-sm:    8px;
      --transition:   0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-ui);
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      overflow: hidden;
      background-image:
        linear-gradient(var(--border) 1px, transparent 1px),
        linear-gradient(90deg, var(--border) 1px, transparent 1px);
      background-size: 40px 40px;
    }

    .app {
      width: 100%;
      max-width: 480px;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    header { text-align: center; }
    .logo {
      font-family: var(--font-display);
      font-size: 1rem; font-weight: 700;
      letter-spacing: 0.2em; text-transform: uppercase; color: var(--muted);
    }
    .logo span { color: var(--accent); }

    /* â”€â”€ Score strip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .score-strip {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: var(--radius); padding: 1rem 1.5rem;
      display: grid; grid-template-columns: 1fr auto 1fr;
      align-items: center; gap: 1rem;
    }
    .stat { display: flex; flex-direction: column; gap: 2px; }
    .stat:last-child { align-items: flex-end; }
    .stat-label { font-size: 0.65rem; font-weight: 600; letter-spacing: 0.12em; text-transform: uppercase; color: var(--muted); }
    .stat-value { font-family: var(--font-display); font-size: 1.5rem; font-weight: 700; color: var(--text); transition: color var(--transition); }
    .stat-value.accent { color: var(--accent); }
    .round-pips { display: flex; gap: 6px; justify-content: center; }
    .pip {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--surface-2); border: 1px solid var(--border);
      transition: background var(--transition), border-color var(--transition), transform var(--transition);
    }
    .pip.done    { background: var(--accent); border-color: var(--accent); }
    .pip.current { background: transparent; border-color: var(--accent); transform: scale(1.3); }

    /* â”€â”€ Arena â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .arena {
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      cursor: pointer;
      height: clamp(260px, 48vw, 360px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      border: 2px solid var(--border);
      background: var(--surface);
      transition: background var(--transition), border-color var(--transition), box-shadow 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Three.js canvas behind everything */
    #threeCanvas {
      position: absolute;
      inset: 0;
      width: 100% !important;
      height: 100% !important;
      pointer-events: none;
    }

    /* Text overlay above canvas */
    .arena-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 0 1.5rem;
    }

    /* â”€â”€ Arena state styles â”€â”€ */
    .arena[data-state="intro"]   { background: var(--surface); border-color: var(--accent); box-shadow: 0 0 30px var(--accent-glow); cursor: default; }
    .arena[data-state="idle"]    { background: var(--surface); border-color: var(--border); cursor: default; }
    .arena[data-state="waiting"] { background: rgba(28,31,46,0.75); border-color: var(--muted); cursor: wait; animation: pulse-wait 1.5s ease-in-out infinite; }
    .arena[data-state="go"]      { background: rgba(28,31,46,0.35); border-color: var(--accent); box-shadow: 0 0 40px var(--accent-glow), inset 0 0 60px var(--accent-dim); cursor: crosshair; }
    .arena[data-state="result"]  { background: rgba(28,31,46,0.72); border-color: var(--accent); cursor: pointer; }
    .arena[data-state="early"]   { background: rgba(28,31,46,0.6); border-color: var(--danger); box-shadow: 0 0 30px rgba(248,113,113,0.25); cursor: pointer; animation: shake 0.4s ease; }
    .arena[data-state="done"]    { background: rgba(28,31,46,0.72); border-color: var(--accent); cursor: default; }

    @keyframes pulse-wait {
      0%, 100% { box-shadow: 0 0 0 0 rgba(100,116,139,0); }
      50%       { box-shadow: 0 0 0 12px rgba(100,116,139,0.12); }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%       { transform: translateX(-8px); }
      40%       { transform: translateX(8px); }
      60%       { transform: translateX(-5px); }
      80%       { transform: translateX(5px); }
    }

    .arena-icon { font-size: 2.5rem; line-height: 1; }
    .arena-title {
      font-family: var(--font-display);
      font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 800;
      letter-spacing: -0.02em; line-height: 1; transition: color var(--transition);
    }
    .arena-subtitle {
      font-size: 0.8rem; font-weight: 500;
      letter-spacing: 0.08em; text-transform: uppercase; color: var(--muted);
      text-align: center;
    }

    /* â”€â”€ Intro overlay (shown inside arena on first load only) â”€â”€ */
    /*
      The intro panel lives inside .arena-content and replaces
      the normal icon/title/subtitle trio. It is only injected
      once and removed permanently when the user dismisses it.
    */
    .intro-panel {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      animation: fade-in 0.5s ease;
    }
    @keyframes fade-in { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

    .intro-title {
      font-family: var(--font-display);
      font-size: 1.4rem; font-weight: 800;
      color: var(--accent); letter-spacing: 0.05em;
    }

    .intro-steps {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .intro-step {
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      font-size: 0.78rem;
      color: var(--text);
      line-height: 1.4;
    }

    .intro-step-num {
      flex-shrink: 0;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent-dim);
      border: 1px solid var(--accent);
      color: var(--accent);
      font-family: var(--font-display);
      font-size: 0.65rem; font-weight: 700;
      display: flex; align-items: center; justify-content: center;
    }

    /* Rating scale inside intro */
    .intro-ratings {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.35rem 0.6rem;
    }

    .intro-rating {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.72rem;
    }

    .rating-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .intro-divider {
      width: 100%;
      height: 1px;
      background: var(--border);
    }

    .intro-cta {
      font-size: 0.7rem;
      color: var(--muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
    }

    .intro-cta kbd {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 4px;
      border: 1px solid var(--muted);
      font-family: var(--font-ui);
      font-size: 0.65rem;
      color: var(--text);
      background: var(--surface-2);
    }

    /* â”€â”€ Rating chip shown after each round and in final results â”€â”€ */
    .rating-chip {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .rating-chip.amazing      { background: rgba(110,231,183,0.18); color: var(--accent);  border: 1px solid var(--accent); }
    .rating-chip.very-good    { background: rgba(129,210,111,0.15); color: #81D26F;         border: 1px solid #81D26F; }
    .rating-chip.average      { background: rgba(251,191,36,0.15);  color: var(--warn);     border: 1px solid var(--warn); }
    .rating-chip.below-avg    { background: rgba(248,113,113,0.15); color: var(--danger);   border: 1px solid var(--danger); }

    /* â”€â”€ History â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .history {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: var(--radius); padding: 1rem 1.5rem; min-height: 64px;
      display: flex; flex-direction: column; gap: 0.6rem;
    }
    .history-header { display: flex; justify-content: space-between; align-items: center; }
    .history-title  { font-size: 0.65rem; font-weight: 600; letter-spacing: 0.12em; text-transform: uppercase; color: var(--muted); }
    .history-clear  {
      background: none; border: none; color: var(--muted); font-family: var(--font-ui);
      font-size: 0.7rem; font-weight: 500; cursor: pointer; padding: 2px 6px;
      border-radius: var(--radius-sm); transition: color var(--transition), background var(--transition);
      letter-spacing: 0.05em; text-transform: uppercase;
    }
    .history-clear:hover { color: var(--danger); background: var(--danger-dim); }
    .history-rows { display: flex; flex-direction: column; gap: 4px; }
    .history-row {
      display: flex; align-items: center; gap: 0.75rem;
      padding: 6px 0; border-bottom: 1px solid var(--border); animation: slide-in 0.2s ease;
    }
    .history-row:last-child { border-bottom: none; }
    @keyframes slide-in { from { opacity: 0; transform: translateY(-6px); } to { opacity: 1; transform: translateY(0); } }
    .history-round { font-size: 0.65rem; color: var(--muted); width: 20px; flex-shrink: 0; }
    .history-bar-wrap { flex: 1; height: 4px; background: var(--surface-2); border-radius: 2px; overflow: hidden; }
    .history-bar { height: 100%; border-radius: 2px; background: var(--accent); transform-origin: left; animation: grow-bar 0.4s cubic-bezier(0.34,1.56,0.64,1) forwards; }
    @keyframes grow-bar { from { transform: scaleX(0); } to { transform: scaleX(1); } }
    .history-ms { font-family: var(--font-display); font-size: 0.85rem; font-weight: 600; min-width: 54px; text-align: right; }
    .history-badge { font-size: 0.6rem; font-weight: 700; padding: 1px 5px; border-radius: 4px; letter-spacing: 0.06em; text-transform: uppercase; width: 36px; text-align: center; flex-shrink: 0; }
    .badge-best  { background: var(--accent-dim); color: var(--accent); }
    .badge-worst { background: var(--danger-dim);  color: var(--danger); }
    .badge-blank { visibility: hidden; }
    .empty-state { text-align: center; color: var(--muted); font-size: 0.8rem; padding: 0.5rem 0; }

    /* â”€â”€ Results grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .arena-result-grid {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.8rem;
      width: 100%;
      padding: 0 1.5rem;
      position: relative;
      z-index: 2;
    }
    .result-stats-row {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      width: 100%;
    }
    .result-stat { display: flex; flex-direction: column; gap: 2px; align-items: center; }
    .result-stat-label { font-size: 0.55rem; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: var(--muted); }
    .result-stat-value { font-family: var(--font-display); font-size: 1.3rem; font-weight: 800; color: var(--accent); }
    .result-stat-unit  { font-size: 0.6rem; color: var(--muted); }
    .result-rating-row { display: flex; flex-direction: column; align-items: center; gap: 0.3rem; }
    .result-rating-label { font-size: 0.6rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.1em; }

    /* â”€â”€ CTA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .btn {
      width: 100%; padding: 1rem; border: none; border-radius: var(--radius);
      font-family: var(--font-display); font-size: 1rem; font-weight: 700;
      letter-spacing: 0.12em; text-transform: uppercase; cursor: pointer;
      transition: background var(--transition), transform 0.1s ease, box-shadow var(--transition);
      background: var(--accent); color: #0F1117;
    }
    .btn:hover  { background: #86efcd; box-shadow: 0 4px 20px var(--accent-glow); }
    .btn:active { transform: scale(0.98); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    footer { text-align: center; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.05em; }

    @media (max-width: 380px) {
      .score-strip { padding: 0.75rem 1rem; }
      .stat-value  { font-size: 1.2rem; }
      .history     { padding: 0.75rem 1rem; }
      .result-stats-row { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
<div class="app">

  <header>
    <div class="logo">React<span>/</span>or</div>
  </header>

  <div class="score-strip">
    <div class="stat">
      <span class="stat-label">Round</span>
      <span class="stat-value" id="roundDisplay">0 / 5</span>
    </div>
    <div class="round-pips" id="pips" aria-hidden="true"></div>
    <div class="stat">
      <span class="stat-label">Avg</span>
      <span class="stat-value" id="avgDisplay">â€” ms</span>
    </div>
  </div>

  <!--
    Arena: data-state drives all CSS & Three.js visuals.
    States: intro â†’ idle â†’ waiting â†’ go â†’ result â†’ done
            (early branches off waiting)
  -->
  <div class="arena" id="arena" data-state="intro" role="button" tabindex="0" aria-label="Reaction arena">
    <canvas id="threeCanvas"></canvas>
    <div class="arena-content" id="arenaContent">
      <!-- Intro panel injected here by JS on first load -->
    </div>
  </div>

  <div class="history">
    <div class="history-header">
      <span class="history-title">Round History</span>
      <button class="history-clear" id="clearBtn">Clear</button>
    </div>
    <div class="history-rows" id="historyRows">
      <p class="empty-state" id="emptyState">No rounds yet</p>
    </div>
  </div>

  <button class="btn" id="mainBtn">Start Game</button>

  <footer id="footerHint">Press <strong>Space</strong> or click Start to begin &nbsp;Â·&nbsp; 5 rounds</footer>

</div>

<script>
  /* ============================================================
     CONSTANTS
     ============================================================ */
  const TOTAL_ROUNDS = 5;
  const DELAY_MIN    = 1500;
  const DELAY_MAX    = 4500;

  /*
    RATING SCALE â€” based on published human reaction time benchmarks:
      Amazing    < 200 ms  (elite athlete / top 5%)
      Very Good  < 250 ms  (above average)
      Average    < 350 ms  (typical adult)
      Below Avg  â‰¥ 350 ms
  */
  const RATINGS = [
    { max: 200, key: 'amazing',   label: 'Amazing',      color: '#6EE7B7', dot: '#6EE7B7' },
    { max: 250, key: 'very-good', label: 'Very Good',    color: '#81D26F', dot: '#81D26F' },
    { max: 350, key: 'average',   label: 'Average',      color: '#FBBF24', dot: '#FBBF24' },
    { max: Infinity, key: 'below-avg', label: 'Below Average', color: '#F87171', dot: '#F87171' },
  ];

  function getRating(ms) {
    return RATINGS.find(r => ms < r.max);
  }

  /* ============================================================
     THREE.JS PARTICLE SYSTEM
     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     WebGLRenderer with alpha:true renders to a transparent canvas
     layered behind all UI. Particles smoothly lerp between
     visual targets for each game state.
     ============================================================ */

  const NUM_PARTICLES = 200;

  const TARGET = {
    intro:   { r: 0.43, g: 0.90, b: 0.72, size: 2.2, speed: 0.25, spread: 0.70 },
    idle:    { r: 0.43, g: 0.90, b: 0.72, size: 1.8, speed: 0.15, spread: 0.55 },
    waiting: { r: 0.55, g: 0.92, b: 0.80, size: 2.4, speed: 0.60, spread: 0.80 },
    go:      { r: 0.43, g: 0.90, b: 0.72, size: 5.0, speed: 2.50, spread: 1.50 },
    early:   { r: 0.97, g: 0.44, b: 0.44, size: 4.0, speed: 3.00, spread: 1.70 },
    result:  { r: 0.43, g: 0.90, b: 0.72, size: 2.6, speed: 0.28, spread: 0.65 },
    done:    { r: 0.43, g: 0.90, b: 0.72, size: 3.0, speed: 0.38, spread: 1.00 },
  };

  let cur          = { ...TARGET.intro };
  let particlePhase = 'intro';

  const threeCanvas = document.getElementById('threeCanvas');
  const arenaEl     = document.getElementById('arena');

  const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene  = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
  camera.position.z = 5;

  const positions = new Float32Array(NUM_PARTICLES * 3);
  const phases    = new Float32Array(NUM_PARTICLES);
  const speeds    = new Float32Array(NUM_PARTICLES);
  const baseAngle = new Float32Array(NUM_PARTICLES);
  const baseR     = new Float32Array(NUM_PARTICLES);

  for (let i = 0; i < NUM_PARTICLES; i++) {
    baseAngle[i] = Math.random() * Math.PI * 2;
    baseR[i]     = Math.random();
    phases[i]    = Math.random() * Math.PI * 2;
    speeds[i]    = 0.4 + Math.random() * 1.2;
    positions[i * 3]     = Math.cos(baseAngle[i]) * baseR[i];
    positions[i * 3 + 1] = Math.sin(baseAngle[i]) * baseR[i];
    positions[i * 3 + 2] = 0;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const mat = new THREE.PointsMaterial({
    color: new THREE.Color(cur.r, cur.g, cur.b),
    size: cur.size / 100,
    sizeAttenuation: false,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });

  const points = new THREE.Points(geo, mat);
  scene.add(points);

  function syncSize() {
    const w = arenaEl.clientWidth;
    const h = arenaEl.clientHeight;
    renderer.setSize(w, h, false);
    const aspect = w / h;
    camera.left  = -aspect;
    camera.right =  aspect;
    camera.updateProjectionMatrix();
  }
  syncSize();
  new ResizeObserver(syncSize).observe(arenaEl);

  const clock = new THREE.Clock();
  let elapsed  = 0;

  function lerp(a, b, t) { return a + (b - a) * t; }

  function tick() {
    requestAnimationFrame(tick);
    elapsed += clock.getDelta();
    const tgt = TARGET[particlePhase] || TARGET.idle;
    const L   = 0.05;

    cur.r      = lerp(cur.r,      tgt.r,      L);
    cur.g      = lerp(cur.g,      tgt.g,      L);
    cur.b      = lerp(cur.b,      tgt.b,      L);
    cur.size   = lerp(cur.size,   tgt.size,   L);
    cur.speed  = lerp(cur.speed,  tgt.speed,  L * 0.4);
    cur.spread = lerp(cur.spread, tgt.spread, L);

    mat.color.setRGB(cur.r, cur.g, cur.b);
    mat.size = cur.size / 100;

    const posAttr = geo.attributes.position;
    const aspect  = camera.right;

    for (let i = 0; i < NUM_PARTICLES; i++) {
      const ph  = phases[i];
      const spd = speeds[i] * cur.speed;
      const r   = (0.1 + baseR[i] * 0.9) * cur.spread;
      const ang = baseAngle[i] + elapsed * spd * 0.3;

      let x = Math.cos(ang + ph * 0.08) * r;
      let y = Math.sin(ang + ph * 0.08) * r * 0.6;
      x += Math.sin(elapsed * 1.3 + ph) * 0.025 * cur.speed;
      y += Math.cos(elapsed * 1.0 + ph) * 0.025 * cur.speed;

      if (particlePhase === 'go' || particlePhase === 'early') {
        const burst = (Math.sin(elapsed * 5.0 + ph) + 1) * 0.5;
        x += Math.cos(ang) * burst * 0.30;
        y += Math.sin(ang) * burst * 0.18;
      }

      posAttr.setXYZ(i, x * aspect, y, 0);
    }

    posAttr.needsUpdate = true;
    renderer.render(scene, camera);
  }
  tick();

  /* ============================================================
     GAME STATE
     ============================================================ */
  let introSeen = false; // tracks whether the intro has been dismissed

  let state = {
    phase:      'intro', // starts on intro screen
    round:      0,
    times:      [],
    stimulusAt: null,
    delayTimer: null,
    earlyTimer: null,
  };

  /* ============================================================
     DOM REFS
     ============================================================ */
  const arenaContent = document.getElementById('arenaContent');
  const roundDisp    = document.getElementById('roundDisplay');
  const avgDisp      = document.getElementById('avgDisplay');
  const pipsEl       = document.getElementById('pips');
  const historyRows  = document.getElementById('historyRows');
  const emptyState   = document.getElementById('emptyState');
  const mainBtn      = document.getElementById('mainBtn');
  const clearBtn     = document.getElementById('clearBtn');
  const footerHint   = document.getElementById('footerHint');

  /* ============================================================
     HELPERS
     ============================================================ */
  const clamp   = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const average = arr => arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : null;
  const randInt = (lo, hi) => Math.floor(Math.random() * (hi - lo + 1)) + lo;
  const barW    = (ms, max) => `${clamp((ms / max) * 100, 4, 100)}%`;

  /** Build a rating chip HTML string */
  function ratingChipHTML(ms) {
    const r = getRating(ms);
    return `<span class="rating-chip ${r.key}">
      <span style="width:6px;height:6px;border-radius:50%;background:${r.dot};display:inline-block;flex-shrink:0;"></span>
      ${r.label}
    </span>`;
  }

  /* ============================================================
     INTRO PANEL
     Built once and injected into arenaContent.
     Dismissed permanently when user starts the game.
     ============================================================ */
  function buildIntroPanel() {
    const panel = document.createElement('div');
    panel.className = 'intro-panel';
    panel.id = 'introPanel';
    panel.innerHTML = `
      <div class="intro-title">How to Play</div>
      <div class="intro-steps">
        <div class="intro-step">
          <div class="intro-step-num">1</div>
          <span>Press <strong>Space</strong> or hit <strong>Start Game</strong> to begin a round.</span>
        </div>
        <div class="intro-step">
          <div class="intro-step-num">2</div>
          <span>Wait for the arena to flash <strong style="color:var(--accent)">green</strong> â€” then click or tap as fast as you can.</span>
        </div>
        <div class="intro-step">
          <div class="intro-step-num">3</div>
          <span>Don't click early! Clicking before the signal restarts the round.</span>
        </div>
      </div>

      <div class="intro-divider"></div>

      <div style="width:100%">
        <div style="font-size:0.6rem;font-weight:600;letter-spacing:0.12em;text-transform:uppercase;color:var(--muted);margin-bottom:0.45rem;">Score Guide</div>
        <div class="intro-ratings">
          ${RATINGS.map(r => `
            <div class="intro-rating">
              <span class="rating-dot" style="background:${r.dot}"></span>
              <span style="color:${r.color};font-weight:600;">${r.label}</span>
              <span style="color:var(--muted);font-size:0.65rem;">${r.max === Infinity ? 'â‰¥ 350ms' : '< ' + r.max + 'ms'}</span>
            </div>
          `).join('')}
        </div>
      </div>

      <div class="intro-divider"></div>

      <div class="intro-cta">Press <kbd>Space</kbd> or click <strong>Start Game</strong> below</div>
    `;
    return panel;
  }

  /* ============================================================
     RENDER â€” syncs all UI with state
     ============================================================ */
  function render() {
    const { phase, round, times } = state;

    // Sync Three.js particle phase
    particlePhase = phase;
    arenaEl.dataset.state = phase;

    // â”€â”€ Clear arena content, then rebuild for current phase
    arenaContent.innerHTML = '';

    switch (phase) {

      case 'intro': {
        /*
          Intro: shown only on first load. Contains "how to play"
          + score guide. Dismissed permanently by starting a game.
          The Start button and footer are visible normally.
        */
        arenaContent.appendChild(buildIntroPanel());
        mainBtn.textContent   = 'Start Game';
        mainBtn.style.display = '';
        mainBtn.disabled      = false;
        footerHint.innerHTML  = 'Press <strong>Space</strong> or click Start to begin &nbsp;Â·&nbsp; 5 rounds';
        break;
      }

      case 'idle': {
        arenaContent.innerHTML = `
          <div class="arena-icon">âš¡</div>
          <div class="arena-title" style="color:var(--text)">React/or</div>
          <div class="arena-subtitle">Ready when you are</div>
        `;
        mainBtn.textContent   = 'Start Game';
        mainBtn.style.display = '';
        mainBtn.disabled      = false;
        footerHint.innerHTML  = 'Press <strong>Space</strong> or click Start';
        break;
      }

      case 'waiting': {
        arenaContent.innerHTML = `
          <div class="arena-icon">ğŸ‘</div>
          <div class="arena-title" style="color:var(--muted)">Wait...</div>
          <div class="arena-subtitle">Get ready â€” click on green</div>
        `;
        mainBtn.style.display = 'none';
        footerHint.innerHTML  = 'Round ${round} of ${TOTAL_ROUNDS}';
        break;
      }

      case 'go': {
        arenaContent.innerHTML = `
          <div class="arena-icon">â—</div>
          <div class="arena-title" style="color:var(--accent)">NOW!</div>
          <div class="arena-subtitle" style="color:var(--accent)">Click / tap as fast as you can</div>
        `;
        mainBtn.style.display = 'none';
        footerHint.innerHTML  = 'Round ${round} of ${TOTAL_ROUNDS}';
        break;
      }

      case 'early': {
        arenaContent.innerHTML = `
          <div class="arena-icon">âœ—</div>
          <div class="arena-title" style="color:var(--danger)">Too Early!</div>
          <div class="arena-subtitle" style="color:var(--danger)">Wait for the green signal</div>
        `;
        mainBtn.style.display = 'none';
        footerHint.innerHTML  = 'Round retryingâ€¦';
        break;
      }

      case 'result': {
        const last   = times[times.length - 1];
        const canContinue = round < TOTAL_ROUNDS;
        arenaContent.innerHTML = `
          <div class="arena-icon">âœ“</div>
          <div class="arena-title" style="color:var(--accent)">${last} ms</div>
          ${ratingChipHTML(last)}
          <div class="arena-subtitle">${canContinue ? 'Click or press Space for next round' : 'Click or press Space to see results'}</div>
        `;
        mainBtn.style.display = 'none';
        footerHint.innerHTML  = `Round ${round} of ${TOTAL_ROUNDS} complete`;
        break;
      }

      case 'done': {
        const best  = Math.min(...times);
        const worst = Math.max(...times);
        const mean  = average(times);
        const avgR  = getRating(mean);

        const grid = document.createElement('div');
        grid.className = 'arena-result-grid';
        grid.innerHTML = `
          <div class="result-stats-row">
            <div class="result-stat">
              <span class="result-stat-label">Average</span>
              <span class="result-stat-value">${mean}</span>
              <span class="result-stat-unit">ms</span>
            </div>
            <div class="result-stat">
              <span class="result-stat-label">Best</span>
              <span class="result-stat-value">${best}</span>
              <span class="result-stat-unit">ms</span>
            </div>
            <div class="result-stat">
              <span class="result-stat-label">Worst</span>
              <span class="result-stat-value">${worst}</span>
              <span class="result-stat-unit">ms</span>
            </div>
            <div class="result-stat">
              <span class="result-stat-label">Rounds</span>
              <span class="result-stat-value">${TOTAL_ROUNDS}</span>
              <span class="result-stat-unit">played</span>
            </div>
          </div>
          <div class="result-rating-row">
            <span class="result-rating-label">Your rating</span>
            ${ratingChipHTML(mean)}
          </div>
        `;
        arenaContent.appendChild(grid);

        mainBtn.textContent   = 'Play Again';
        mainBtn.style.display = '';
        mainBtn.disabled      = false;
        footerHint.innerHTML  = 'Press <strong>Space</strong> or click Play Again';
        break;
      }
    }

    // â”€â”€ Score strip
    roundDisp.textContent = `${round} / ${TOTAL_ROUNDS}`;
    const avg = average(times);
    avgDisp.textContent = avg !== null ? `${avg} ms` : 'â€” ms';
    avgDisp.classList.toggle('accent', avg !== null);

    // â”€â”€ Round pips
    pipsEl.innerHTML = '';
    for (let i = 1; i <= TOTAL_ROUNDS; i++) {
      const pip = document.createElement('div');
      pip.className = 'pip';
      if (i < round || (i === round && phase === 'result')) pip.classList.add('done');
      else if (i === round && phase !== 'idle' && phase !== 'intro') pip.classList.add('current');
      pipsEl.appendChild(pip);
    }

    renderHistory();
  }

  function renderHistory() {
    const { times } = state;
    if (times.length === 0) {
      historyRows.innerHTML = '';
      emptyState.style.display = 'block';
      historyRows.appendChild(emptyState);
      return;
    }
    emptyState.style.display = 'none';
    const maxTime = Math.max(...times);
    const minIdx  = times.indexOf(Math.min(...times));
    const maxIdx  = times.indexOf(maxTime);
    if (historyRows.querySelectorAll('.history-row').length === times.length) return;
    historyRows.innerHTML = '';
    times.forEach((ms, i) => {
      const isBest  = i === minIdx && times.length > 1;
      const isWorst = i === maxIdx && times.length > 1;
      const row = document.createElement('div');
      row.className = 'history-row';
      row.innerHTML = `
        <span class="history-round">${i + 1}</span>
        <div class="history-bar-wrap"><div class="history-bar" style="width:${barW(ms, maxTime)}"></div></div>
        <span class="history-ms">${ms} ms</span>
        <span class="history-badge ${isBest ? 'badge-best' : isWorst ? 'badge-worst' : 'badge-blank'}">
          ${isBest ? 'Best' : isWorst ? 'Slow' : ''}</span>`;
      historyRows.appendChild(row);
    });
  }

  /* ============================================================
     GAME LOGIC
     ============================================================ */

  function startRound() {
    state.round++;
    state.phase = 'waiting';
    render();

    state.delayTimer = setTimeout(() => {
      state.phase      = 'go';
      state.stimulusAt = performance.now();
      render();
    }, randInt(DELAY_MIN, DELAY_MAX));
  }

  /** Dismiss the intro and move to idle, then immediately start */
  function dismissIntroAndStart() {
    introSeen = true;
    resetGame(); // sets phase to 'idle'
    startRound();
  }

  function handleArenaClick() {
    const { phase } = state;

    // Clicking anywhere on the arena during intro starts the game
    if (phase === 'intro') {
      dismissIntroAndStart();
      return;
    }

    if (phase === 'waiting') {
      clearTimeout(state.delayTimer);
      state.phase = 'early';
      render();
      state.earlyTimer = setTimeout(() => { state.round--; startRound(); }, 1500);
      return;
    }

    if (phase === 'go') {
      const elapsed = Math.round(performance.now() - state.stimulusAt);
      state.times.push(elapsed);
      state.phase = 'result';
      render();
      return;
    }

    if (phase === 'result') {
      if (state.round < TOTAL_ROUNDS) startRound();
      else { state.phase = 'done'; render(); }
    }
  }

  function resetGame() {
    clearTimeout(state.delayTimer);
    clearTimeout(state.earlyTimer);
    // After intro is seen, reset goes to idle not intro
    state = { phase: 'idle', round: 0, times: [], stimulusAt: null, delayTimer: null, earlyTimer: null };
    render();
  }

  /* ============================================================
     SPACEBAR TRIGGER
     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     Space acts as the universal "primary action" key:
       intro   â†’ dismiss intro + start
       idle    â†’ start game
       result  â†’ advance to next round or results
       done    â†’ reset + start again
       go      â†’ register reaction (same as click)
       waiting â†’ penalise early press
     We preventDefault to stop the page from scrolling.
     ============================================================ */
  document.addEventListener('keydown', e => {
    if (e.code !== 'Space') return;
    e.preventDefault();

    const { phase } = state;

    if (phase === 'intro' || phase === 'idle') {
      if (phase === 'intro') dismissIntroAndStart();
      else { resetGame(); startRound(); }
      return;
    }
    if (phase === 'done') { resetGame(); startRound(); return; }

    // For in-game phases, delegate to arena click handler
    handleArenaClick();
  });

  /* ============================================================
     EVENT LISTENERS
     ============================================================ */
  arenaEl.addEventListener('click', handleArenaClick);
  arenaEl.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); handleArenaClick(); }
  });

  mainBtn.addEventListener('click', () => {
    const { phase } = state;
    if (phase === 'intro') { dismissIntroAndStart(); return; }
    if (phase === 'idle' || phase === 'done') { resetGame(); startRound(); }
  });

  clearBtn.addEventListener('click', () => {
    // After intro was seen, clear returns to idle (not intro)
    if (introSeen) resetGame();
    else { state = { phase: 'intro', round: 0, times: [], stimulusAt: null, delayTimer: null, earlyTimer: null }; render(); }
  });

  /* ============================================================
     INIT â€” start on intro screen
     ============================================================ */
  render();
</script>
</body>
</html>